#!/usr/bin/env bash
set -euo pipefail

# Resolve the directory where this script lives (follows symlinks)
SCRIPT_PATH="$(readlink -f "$0")"
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

CONFIG_FILE="${HOME}/.config/wf-workspace/config"

# --- First-run setup ---
if [[ ! -f "$CONFIG_FILE" ]]; then
  echo ""
  echo "Welcome to wf-workspace! Let's set things up."
  echo ""
  echo "(Press Enter to accept defaults shown in brackets)"
  echo ""

  default_prefix="$(git config user.name 2>/dev/null | awk '{print tolower($1)}' || true)"
  if [[ -z "$default_prefix" ]]; then
    default_prefix="$(whoami)"
  fi
  read -rp "Branch prefix (your name) [$default_prefix]: " input_prefix
  input_prefix="${input_prefix:-$default_prefix}"

  mkdir -p "$(dirname "$CONFIG_FILE")"
  cat > "$CONFIG_FILE" << EOF
BRANCH_PREFIX="$input_prefix"
EOF

  echo ""
  echo "Config saved to $CONFIG_FILE"

  # Offer to symlink into ~/bin
  bin_link="$HOME/bin/wf-workspace"
  if [[ "$SCRIPT_PATH" != "$bin_link" && "$(readlink -f "$bin_link" 2>/dev/null)" != "$SCRIPT_PATH" ]]; then
    echo ""
    read -rp "Symlink scripts into ~/bin for easy access? [Y/n]: " symlink_choice
    symlink_choice="${symlink_choice:-y}"
    if [[ "$symlink_choice" =~ ^[Yy] ]]; then
      mkdir -p "$HOME/bin"
      ln -sf "$SCRIPT_PATH" "$HOME/bin/wf-workspace"
      monitor_path="$SCRIPT_DIR/wf-workspace-monitor"
      if [[ -f "$monitor_path" ]]; then
        ln -sf "$monitor_path" "$HOME/bin/wf-workspace-monitor"
      fi
      echo "Symlinked into ~/bin/"

      if [[ ":$PATH:" != *":$HOME/bin:"* ]]; then
        echo ""
        echo "Note: ~/bin is not in your PATH. Add this to your shell profile:"
        echo '  export PATH="$HOME/bin:$PATH"'
      fi
    fi
  fi

  echo ""
  echo "Setup complete! Re-run your command to get started."
  exit 0
fi

# --- Load config ---
# shellcheck source=/dev/null
source "$CONFIG_FILE"

if [[ -z "${BRANCH_PREFIX:-}" ]]; then
  echo "Error: BRANCH_PREFIX not set in $CONFIG_FILE"
  exit 1
fi

# --- Repo detection ---
detect_repo() {
  local dir="${1:-$PWD}"
  local git_dir
  git_dir="$(git -C "$dir" rev-parse --path-format=absolute --git-common-dir 2>/dev/null || true)"
  if [[ -n "$git_dir" ]]; then
    # git-common-dir returns <repo>/.git — go up one level
    dirname "$git_dir"
    return 0
  fi
  return 1
}

# Derive all settings from repo path
setup_repo_vars() {
  WORKTREE_BASE="${MAIN_REPO}-worktrees"
  SESSION="$(basename "$MAIN_REPO")"
}

usage() {
  echo "Usage:"
  echo "  wf-workspace [name] [options]"
  echo "  wf-workspace close [name] [--force]"
  echo ""
  echo "Create mode:"
  echo "  Creates a git worktree and adds it as a tab in a tmux session."
  echo "  Each tab has: claude (left 70%), tig status (top-right), dev server (bottom-right)"
  echo "  Tab colors indicate Claude's state: green=working, yellow=done, red=needs approval"
  echo "  tmux shortcuts: Prefix + N creates a workspace, Prefix + X closes current workspace"
  echo ""
  echo "Close mode:"
  echo "  Stops the worktree dev server, removes the git worktree, and closes the tmux tab."
  echo ""
  echo "Arguments:"
  echo "  name          Branch suffix (creates ${BRANCH_PREFIX}/<name>). Default: auto-generated in create mode"
  echo ""
  echo "Options:"
  echo "  -r, --repo PATH     Repo to use (default: auto-detect from CWD)"
  echo "  -b, --base BRANCH   Base branch to create worktree from (default: auto-detect)"
  echo "  -e, --existing      Use existing worktree (don't create new)"
  echo "  -f, --force         Force removal in close mode (allows dirty worktree removal)"
  echo "  -i, --interactive   Prompt before closing (used automatically when Claude exits)"
  echo "  -h, --help          Show this help"
  echo ""
  echo "Examples:"
  echo "  wf-workspace fix-login        # New tab in repo detected from CWD"
  echo "  wf-workspace                  # New tab: ${BRANCH_PREFIX}/workspace-<timestamp>"
  echo "  wf-workspace -e fix-login     # Tab for existing worktree"
  echo "  wf-workspace close fix-login  # Stop server, remove worktree, close tmux tab"
  echo "  wf-workspace close            # Close current tmux tab/worktree"
}

resolve_current_workspace_name() {
  local inferred_name=""

  if [[ -n "${TMUX:-}" ]] && tmux has-session -t "$SESSION" 2>/dev/null; then
    local current_session
    current_session="$(tmux display-message -p '#S' 2>/dev/null || true)"
    if [[ "$current_session" == "$SESSION" ]]; then
      inferred_name="$(tmux display-message -p '#W' 2>/dev/null || true)"
    fi
  fi

  if [[ -z "$inferred_name" && "$PWD" == "$WORKTREE_BASE/"* ]]; then
    local relative_path
    relative_path="${PWD#"$WORKTREE_BASE/"}"
    inferred_name="${relative_path%%/*}"
  fi

  echo "$inferred_name"
}

close_workspace() {
  local requested_name="$1"
  local force_remove="$2"
  local interactive="${3:-false}"

  local name="$requested_name"
  if [[ -z "$name" ]]; then
    name="$(resolve_current_workspace_name)"
  fi

  if [[ -z "$name" ]]; then
    echo "Error: Could not infer workspace name."
    echo "Run: wf-workspace close <name>"
    exit 1
  fi

  local worktree_dir="$WORKTREE_BASE/$name"

  if [[ "$interactive" == true ]]; then
    echo ""
    read -rp "Close workspace '$name'? [Y/n]: " choice
    choice="${choice:-y}"
    if [[ ! "$choice" =~ ^[Yy] ]]; then
      echo "Workspace kept. Run: wf-workspace close $name"
      return 1
    fi
  fi

  echo "Closing workspace: $name"
  echo "  Worktree: $worktree_dir"

  if [[ -d "$worktree_dir" ]]; then
    if [[ "$force_remove" != true ]]; then
      local git_status
      git_status="$(git -C "$worktree_dir" status --porcelain 2>/dev/null || true)"
      if [[ -n "$git_status" ]]; then
        if [[ "$interactive" == true ]]; then
          echo ""
          echo "⚠️  Worktree has uncommitted changes:"
          git -C "$worktree_dir" status --short 2>/dev/null || true
          echo ""
          read -rp "Force close anyway? [y/N]: " force_choice
          if [[ "$force_choice" =~ ^[Yy] ]]; then
            force_remove=true
          else
            echo "Workspace kept."
            echo "To force close with uncommitted changes, run:"
            echo "  wf-workspace close $name --force"
            return 1
          fi
        else
          echo ""
          echo "Refusing to remove dirty worktree: $worktree_dir"
          echo "Commit/stash changes first, or rerun with:"
          echo "  wf-workspace close $name --force"
          exit 1
        fi
      fi
    fi

    if [[ -x "$worktree_dir/bin/dev-worktree" ]]; then
      (cd "$worktree_dir" && bin/dev-worktree stop > /dev/null 2>&1 || true)
    fi

    if [[ "$force_remove" == true ]]; then
      git -C "$MAIN_REPO" worktree remove --force "$worktree_dir"
    else
      git -C "$MAIN_REPO" worktree remove "$worktree_dir"
    fi
    echo "✓ Removed git worktree"
  else
    echo "⚠️  Worktree directory not found, skipping git worktree removal"
  fi

  if tmux has-session -t "$SESSION" 2>/dev/null; then
    if tmux list-windows -t "$SESSION" -F "#{window_name}" 2>/dev/null | grep -qx "$name"; then
      tmux kill-window -t "$SESSION:$name" 2>/dev/null || true
      echo "✓ Closed tmux tab: $name"
    else
      echo "ℹ️  No tmux tab named '$name' in session '$SESSION'"
    fi
  fi
}

# Parse command
COMMAND="create"
REPO_OVERRIDE=""

if [[ $# -gt 0 ]]; then
  case "$1" in
    close)
      COMMAND="close"
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
  esac
fi

if [[ "$COMMAND" == "close" ]]; then
  NAME=""
  FORCE_REMOVE=false
  INTERACTIVE=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -r|--repo)
        REPO_OVERRIDE="$2"
        shift 2
        ;;
      -f|--force)
        FORCE_REMOVE=true
        shift
        ;;
      -i|--interactive)
        INTERACTIVE=true
        shift
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      -*)
        echo "Unknown option: $1"
        usage
        exit 1
        ;;
      *)
        NAME="$1"
        shift
        ;;
    esac
  done

  # Resolve repo
  if [[ -n "$REPO_OVERRIDE" ]]; then
    MAIN_REPO="$REPO_OVERRIDE"
  elif ! MAIN_REPO="$(detect_repo)"; then
    echo "Error: Not in a git repo. Use -r to specify."
    exit 1
  fi
  setup_repo_vars

  close_workspace "$NAME" "$FORCE_REMOVE" "$INTERACTIVE"
  exit 0
fi

# Parse create-mode arguments
BASE_BRANCH=""
EXISTING=false
NAME=""

while [[ $# -gt 0 ]]; do
  case $1 in
    -r|--repo)
      REPO_OVERRIDE="$2"
      shift 2
      ;;
    -b|--base)
      BASE_BRANCH="$2"
      shift 2
      ;;
    -e|--existing)
      EXISTING=true
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    -*)
      echo "Unknown option: $1"
      usage
      exit 1
      ;;
    *)
      NAME="$1"
      shift
      ;;
  esac
done

# Resolve repo
if [[ -n "$REPO_OVERRIDE" ]]; then
  MAIN_REPO="$REPO_OVERRIDE"
elif ! MAIN_REPO="$(detect_repo)"; then
  echo "Error: Not in a git repo. Use -r to specify."
  exit 1
fi
setup_repo_vars

# Generate name if not provided
if [[ -z "$NAME" ]]; then
  NAME="workspace-$(date +%m%d-%H%M)"
fi

# Auto-detect default branch if not specified
if [[ -z "$BASE_BRANCH" ]]; then
  BASE_BRANCH="$(git -C "$MAIN_REPO" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|refs/remotes/origin/||' || true)"
  if [[ -z "$BASE_BRANCH" ]]; then
    for candidate in master main; do
      if git -C "$MAIN_REPO" rev-parse --verify "origin/$candidate" &>/dev/null; then
        BASE_BRANCH="$candidate"
        break
      fi
    done
  fi
  if [[ -z "$BASE_BRANCH" ]]; then
    echo "Error: Could not detect default branch. Use -b to specify."
    exit 1
  fi
fi

BRANCH="$BRANCH_PREFIX/$NAME"
WORKTREE_DIR="$WORKTREE_BASE/$NAME"

# --- Worktree setup ---
if [[ "$EXISTING" == true ]]; then
  if [[ ! -d "$WORKTREE_DIR" ]]; then
    echo "Error: Worktree not found at $WORKTREE_DIR"
    echo ""
    echo "Existing worktrees:"
    git -C "$MAIN_REPO" worktree list
    exit 1
  fi
else
  mkdir -p "$WORKTREE_BASE"

  if [[ -d "$WORKTREE_DIR" ]]; then
    echo "Worktree already exists at $WORKTREE_DIR, reusing it."
  else
    echo "Creating worktree: $WORKTREE_DIR (branch: $BRANCH)"
    cd "$MAIN_REPO"
    git fetch origin "$BASE_BRANCH" --quiet 2>/dev/null || true

    if git worktree add "$WORKTREE_DIR" -b "$BRANCH" "origin/$BASE_BRANCH" 2>/dev/null; then
      echo "Created new branch: $BRANCH"
    elif git worktree add "$WORKTREE_DIR" "$BRANCH" 2>/dev/null; then
      echo "Using existing branch: $BRANCH"
    else
      echo "Error: Failed to create worktree."
      echo "Check if branch '$BRANCH' already exists with a different worktree."
      git worktree list
      exit 1
    fi
  fi
fi

# --- tmux setup ---
SESSION_EXISTS=false
if tmux has-session -t "$SESSION" 2>/dev/null; then
  SESSION_EXISTS=true
fi

configure_tmux_mouse_clipboard() {
  tmux set-option -g mouse on
  tmux bind-key -T copy-mode-vi MouseDragEnd1Pane send-keys -X copy-pipe-and-cancel "pbcopy"
  tmux bind-key -T copy-mode MouseDragEnd1Pane send-keys -X copy-pipe-and-cancel "pbcopy"
}

configure_tmux_workspace_bindings() {
  local wf_cmd="$SCRIPT_PATH"
  # Prefix + N: create a new workspace from inside tmux
  tmux bind-key -T prefix N display-popup -E "bash -lc 'read -rp \"New workspace name (blank=auto): \" name; if [[ -n \"\$name\" ]]; then \"$wf_cmd\" \"\$name\"; else \"$wf_cmd\"; fi'"
  # Prefix + X: close current workspace
  tmux bind-key -T prefix X display-popup -E "\"$wf_cmd\" close --interactive #{window_name}"
}

inside_session() {
  if [[ -z "${TMUX:-}" ]]; then
    return 1
  fi
  local current_session
  current_session="$(tmux display-message -p '#S' 2>/dev/null || true)"
  [[ "$current_session" == "$SESSION" ]]
}

# Ensure mouse drag selection copies to macOS clipboard
if [[ "$SESSION_EXISTS" == true ]]; then
  configure_tmux_mouse_clipboard
  configure_tmux_workspace_bindings
fi

# Check if a window with this name already exists
if [[ "$SESSION_EXISTS" == true ]] && tmux list-windows -t "$SESSION" -F "#{window_name}" 2>/dev/null | grep -qx "$NAME"; then
  echo "Tab '$NAME' already exists. Switching to it..."
  tmux select-window -t "$SESSION:$NAME"
  if inside_session; then
    exit 0
  fi
  exec tmux attach -t "$SESSION"
fi

setup_window_panes() {
  local target="$1"

  # Split right side for tig (pane 1 = top-right)
  tmux split-window -h -t "$target" -c "$WORKTREE_DIR" \
    "tig status"

  # Split right pane for dev server if available (pane 2 = bottom-right)
  if [[ -x "$WORKTREE_DIR/bin/dev-worktree" ]]; then
    tmux split-window -v -t "${target}.1" -c "$WORKTREE_DIR" \
      "bin/dev-worktree start; echo ''; echo 'Dev server stopped. Press Enter to close.'; read"
  fi

  # Claude gets 70% width
  tmux resize-pane -t "${target}.0" -x "70%"
}

# Ask which CLI to open
echo ""
read -rp "Which CLI do you want to open? ([claude]/agent): " CLI_CHOICE
CLI_CHOICE="${CLI_CHOICE:-claude}"

if [[ "$CLI_CHOICE" == "agent" ]]; then
  CLI_CMD="agent"
  CLI_LABEL="agent (Cursor)"
else
  CLI_CMD="claude"
  CLI_LABEL="claude"
fi

echo ""
echo "  Repo: $MAIN_REPO"
echo "  Tab: $NAME"
echo "  Worktree: $WORKTREE_DIR"
echo "  Left:         $CLI_LABEL (70%)"
echo "  Top-right:    tig status (30%, press q to close pane)"
if [[ -x "$WORKTREE_DIR/bin/dev-worktree" || ! -d "$WORKTREE_DIR" ]]; then
  echo "  Bottom-right: dev server (30%)"
fi
echo "  Shortcuts:    Prefix + N new workspace, Prefix + X close workspace"
echo ""

if [[ "$SESSION_EXISTS" == true ]]; then
  tmux new-window -t "$SESSION" -n "$NAME" -c "$WORKTREE_DIR" \
    "$CLI_CMD; $SCRIPT_PATH close -r $MAIN_REPO --interactive $NAME; echo 'Press Enter to close pane.'; read"

  setup_window_panes "$SESSION:$NAME"
  tmux select-window -t "$SESSION:$NAME"
else
  tmux new-session -d -s "$SESSION" -n "$NAME" -c "$WORKTREE_DIR" \
    "$CLI_CMD; $SCRIPT_PATH close -r $MAIN_REPO --interactive $NAME; echo 'Press Enter to close pane.'; read"

  setup_window_panes "$SESSION:$NAME"
  configure_tmux_mouse_clipboard
  configure_tmux_workspace_bindings
fi

# Start monitor if not already running
if ! pgrep -f "wf-workspace-monitor" > /dev/null 2>&1; then
  nohup "$SCRIPT_DIR/wf-workspace-monitor" > /dev/null 2>&1 &
  disown
fi

if inside_session; then
  exit 0
fi

exec tmux attach -t "$SESSION"
